// Copyright 2019 libsbn project contributors.
// libsbn is free software under the GPLv3; see LICENSE file for details.

#ifndef SRC_SBN_PROBABILITY_HPP_
#define SRC_SBN_PROBABILITY_HPP_

#include "eigen_sugar.hpp"
#include "sbn_maps.hpp"

using IndexerRepresentationCounter =
    std::vector<std::pair<IndexerRepresentation, uint32_t>>;

namespace SBNProbability {

// Turn a TopologyCounter into an IndexerRepresentationCounter.
IndexerRepresentationCounter IndexerRepresentationCounterOf(
    const BitsetSizeMap& indexer, const Node::TopologyCounter& topology_counter);

// The "SBN-SA" estimator described in the "Maximum Lower Bound Estimates" section of
// the 2018 NeurIPS paper.
void SimpleAverage(EigenVectorXdRef sbn_parameters,
                   const IndexerRepresentationCounter& indexer_representation_counter,
                   size_t rootsplit_count, const BitsetSizePairMap& parent_to_range);

// The "SBN-EM" estimator described in the "Expectation Maximization" section of
// the 2018 NeurIPS paper.
void ExpectationMaximization(
    EigenVectorXdRef sbn_parameters,
    const IndexerRepresentationCounter& indexer_representation_counter,
    size_t rootsplit_count, const BitsetSizePairMap& parent_to_range, double alpha,
    size_t em_loop_count);

// Calculate the probability of an indexer_representation of a topology.
double ProbabilityOf(const EigenConstVectorXdRef,
                     const IndexerRepresentation& indexer_representation);

// Calculate the probabilities of a collection of indexer_representations.
EigenVectorXd ProbabilityOf(
    const EigenConstVectorXdRef sbn_parameters,
    const std::vector<IndexerRepresentation>& indexer_representations);

}  // namespace SBNProbability

#ifdef DOCTEST_LIBRARY_INCLUDED
TEST_CASE("sbn_probability") {
    // 1. do 1 iteration of EM with alpha = 0 and compare against hard coded values obtained from Cheng's code
    // 2. do 23 iteration of EM with alpha = 0 and compare against hard coded values obtained from Cheng's code

    SBNInstance inst("charlie");
    // Reading one file after another checks that we've cleared out state.
    //inst.ReadNewickFile("/Users/sjun2/libsbn/data/five_taxon.nwk");
    inst.ReadNewickFile("data/DS1.100_topologies.nwk");
    inst.ProcessLoadedTrees();
    inst.TrainExpectationMaximization(0, 1);
    EigenVectorXd realized_em0_1 = inst.CalculateSBNProbabilities();

    EigenVectorXd expected_em0_1(100);
    expected_em0_1 << 0.15636219370379975,
    0.15636219370379975,
    0.12263720847530954,
    0.0038161261257420274,
    0.0641198257552132,
    0.12263720847530954,
    0.006486659269203554,
    0.07229291766902365,
    0.07229291766902365,
    0.09217334703350938,
    0.05029011931468532,
    0.07229291766902365,
    0.12263720847530954,
    0.004003916595779366,
    0.0007856587472007348,
    0.01573322403407416,
    0.0007374660239687015,
    0.09217334703350938,
    0.05029011931468532,
    0.15636219370379975,
    0.004512401354352734,
    0.12263720847530954,
    0.02005981904435064,
    0.07229291766902365,
    0.008265715290818319,
    0.15636219370379975,
    0.05029011931468532,
    0.09217334703350938,
    6.696764561669613e-06,
    0.0120117421642559,
    0.0010771644269441463,
    0.004896166585246872,
    0.005249064166033721,
    0.15636219370379975,
    0.006473675486085066,
    0.05029011931468532,
    0.0032873955583662736,
    0.15636219370379975,
    0.07229291766902365,
    0.0036100017361450775,
    0.009434696399838294,
    0.0056590388012875215,
    0.007977630170932788,
    0.12263720847530954,
    0.15636219370379975,
    0.006482919565829875,
    0.15636219370379975,
    0.006552518113293269,
    0.12263720847530954,
    0.12263720847530954,
    0.0641198257552132,
    0.0641198257552132,
    0.09217334703350938,
    0.0062569566301722964,
    0.006486659269203554,
    0.15636219370379975,
    0.002157895979240378,
    0.008270476015894701,
    0.012800407342249945,
    0.12263720847530954,
    0.0057533024269482485,
    0.12263720847530954,
    0.15636219370379975,
    0.12263720847530954,
    0.15636219370379975,
    0.004509802427487057,
    0.15636219370379975,
    0.0641198257552132,
    0.05029011931468532,
    0.00016356223078203,
    0.12263720847530954,
    0.15636219370379975,
    0.05029011931468532,
    0.15636219370379975,
    0.0039366703105347105,
    0.09217334703350938,
    0.07229291766902365,
    0.15636219370379975,
    0.12263720847530954,
    0.01202920464244238,
    0.00028206667942050513,
    0.005749993943460951,
    0.0029930413584166584,
    0.00329320520591652,
    0.09217334703350938,
    0.12263720847530954,
    0.0015794165564839767,
    0.15636219370379975,
    0.12263720847530954,
    0.009434696399838294,
    0.0080145373179354,
    0.008270476015894701,
    0.12263720847530954,
    0.15636219370379975,
    0.012800407342249945,
    0.008265715290818319,
    0.15636219370379975,
    0.15636219370379975,
    0.01573322403407416,
    0.0014108855861473272;

    for (size_t i = 0; i < expected_em0_1.size(); i++) {
        CHECK_LT(fabs(realized_em0_1(i) - expected_em0_1(i)), 0.00011);
    }

    EigenVectorXd expected_em0_23(100);
    expected_em0_23 << 0.17652149361215352,
    0.17652149361215352,
    0.13955673648946823,
    0.0064491608851600735,
    0.05848390318274005,
    0.13955673648946823,
    0.015825262650921094,
    0.056647494412346275,
    0.056647494412346275,
    0.07263326598713499,
    0.046048205076811774,
    0.056647494412346275,
    0.13955673648946823,
    0.004489402988562556,
    0.0008454696589522312,
    0.01696511452269485,
    0.0007597630896160637,
    0.07263326598713499,
    0.046048205076811774,
    0.17652149361215352,
    0.007245923330084535,
    0.13955673648946823,
    0.021613944434184986,
    0.056647494412346275,
    0.014714698661351094,
    0.17652149361215352,
    0.046048205076811774,
    0.07263326598713499,
    9.203216973858281e-06,
    0.012351059173222767,
    0.0009871200936099765,
    0.004930024591016917,
    0.00491121394019874,
    0.17652149361215352,
    0.003698082517142961,
    0.046048205076811774,
    0.005102502844331727,
    0.17652149361215352,
    0.056647494412346275,
    0.002888359861489329,
    0.010768901737247942,
    0.004400293712986419,
    0.009082480764670433,
    0.13955673648946823,
    0.17652149361215352,
    0.011355455748479546,
    0.1765214936121535,
    0.004904756855047689,
    0.13955673648946823,
    0.13955673648946823,
    0.05848390318274005,
    0.05848390318274005,
    0.07263326598713499,
    0.0071809191341133454,
    0.015825262650921094,
    0.17652149361215352,
    0.002748656816901356,
    0.020534769315758854,
    0.015225481783759537,
    0.13955673648946823,
    0.009401422446411185,
    0.13955673648946823,
    0.17652149361215352,
    0.13955673648946823,
    0.17652149361215352,
    0.005835611123722098,
    0.17652149361215352,
    0.05848390318274005,
    0.046048205076811774,
    0.00021701159553434837,
    0.13955673648946823,
    0.17652149361215352,
    0.046048205076811774,
    0.17652149361215352,
    0.003632704913367913,
    0.07263326598713499,
    0.056647494412346275,
    0.17652149361215352,
    0.13955673648946823,
    0.013620606755282007,
    0.0013952624329697414,
    0.007542542618796534,
    0.004980505041486884,
    0.0049091058169283925,
    0.07263326598713499,
    0.13955673648946823,
    0.0018467480153313562,
    0.17652149361215352,
    0.13955673648946823,
    0.010768901737247942,
    0.00801061474692208,
    0.020534769315758854,
    0.13955673648946823,
    0.17652149361215352,
    0.015225481783759537,
    0.014714698661351094,
    0.1765214936121535,
    0.17652149361215352,
    0.01696511452269485,
    0.0010195073633053277;

    inst.TrainExpectationMaximization(0, 23);
    EigenVectorXd realized_em0_23 = inst.CalculateSBNProbabilities();
    for (size_t i = 0; i < expected_em0_1.size(); i++) {
        CHECK_LT(fabs(realized_em0_23(i) - expected_em0_23(i)), 0.00011);
    }
}

#endif  // DOCTEST_LIBRARY_INCLUDED
#endif  // SRC_SBN_PROBABILITY_HPP_
