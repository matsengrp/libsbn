#include "stopwatch.hpp"
#include "gp_instance.hpp"
#include "rooted_sbn_instance.hpp"
#include "unrooted_sbn_instance.hpp"
#include "rooted_tree_collection.hpp"

// This is just a place to muck around, and check out performance.

auto now = std::chrono::high_resolution_clock::now;

// To valgrind (you can pip install gprof2dot):
// valgrind --tool=callgrind ./_build/noodle
// gprof2dot -f callgrind callgrind.out.16763 | dot -Tpng -o ~/output.png

auto GetArgVec(int argc, char* argv[]) {
  std::string current_exec_name = argv[0];  // Name of the current exec program
  std::vector<std::string> all_args;
  if (argc > 1) {
    all_args.assign(argv + 1, argv + argc);
  }
  return all_args;
}

auto MakeGPInstanceFromFiles(std::string& fasta_path, std::string& newick_path) {
  GPInstance inst("../_ignore/mmap.data");
  inst.ReadFastaFile(fasta_path);
  inst.ReadNewickFile(newick_path);
  return inst;
}

void BuildAllSubsplitsRecurse(std::vector<int>& subsplit_assign, size_t n,
                              std::set<Bitset>& results) {
  if (n > 0) {
    for (size_t i = 0; i < 3; i++) {
      subsplit_assign[subsplit_assign.size() - 1 - n] = i;
      BuildAllSubsplitsRecurse(subsplit_assign, n - 1, results);
    }
    return;
  }
  if (n == 0) {
    Bitset clade_left(subsplit_assign.size(), false);
    Bitset clade_right(subsplit_assign.size(), false);
    for (size_t i = 0; i < subsplit_assign.size(); i++) {
      if (subsplit_assign[i] == 0) {
        clade_left.set(i);
      }
      if (subsplit_assign[i] == 1) {
        clade_right.set(i);
      }
    }
    if ((clade_left.Count() == 0) && (clade_right.Count() == 0)) {
      return;
    }
    if ((clade_left.Count() == 0) && (clade_right.Count() > 1)) {
      return;
    }
    if ((clade_left.Count() > 1) && (clade_right.Count() == 0)) {
      return;
    }
    Bitset subsplit = Bitset::Subsplit(clade_left, clade_right);
    results.insert(subsplit);
    return;
  }
}

std::set<Bitset> BuildAllSubsplits(size_t n) {
  std::vector<int> subsplit_assign(n);
  std::set<Bitset> all_subsplits;
  BuildAllSubsplitsRecurse(subsplit_assign, n, all_subsplits);
  std::cout << "all_subsplits: " << n << " " << all_subsplits.size() << " "
            << all_subsplits << std::endl;
  // return all_subsplits;
}

int main(int argc, char* argv[]) {
  auto args = GetArgVec(argc, argv);
  if (args.size() != 2) {
    std::cout << "usage: <fasta_path> <newick_path>" << std::endl;
    exit(0);
  }

  auto fasta_path = args[0];
  auto newick_path = args[1];
  bool use_gp = true;

  std::cout << "Fasta: " << fasta_path << std::endl;
  std::cout << "Newick: " << newick_path << std::endl;

  auto inst = MakeGPInstanceFromFiles(fasta_path, newick_path);
  inst.MakeDAG();
  auto& dag = inst.GetDAG();
  inst.MakeGPEngine();
  inst.MakeTPEngine();
  inst.MakeNNIEngine();
  auto& nni_engine = inst.GetNNIEngine();

  // inst.TakeFirstBranchLength();
  auto& gp_engine = inst.GetGPEngine();
  inst.EstimateBranchLengths(1e-5, 5);
  inst.TPEngineSetChoiceMapByTakingFirst();
  auto& tp_engine = inst.GetTPEngine();
  tp_engine.OptimizeBranchLengths(false);

  nni_engine.SetGPLikelihoodCutoffFilteringScheme(0.0);
  // nni_engine.SetTPLikelihoodCutoffFilteringScheme(0.0);
  nni_engine.SetTopNScoreFilteringScheme(5);

  std::cout << "Initial DAG: " << dag.TaxonCount() << " " << dag.NodeCount() << " "
            << dag.EdgeCountWithLeafSubsplits() << std::endl;
  // BuildAllSubsplits(dag.TaxonCount());
  std::cout
      << "TPEngine::BranchLengths: "
      << tp_engine.GetLikelihoodEvalEngine().GetDAGBranchHandler().GetBranchLengthData()
      << std::endl;
  std::cout << "GPEngine::BranchLengths: "
            << gp_engine.GetBranchLengthHandler().GetBranchLengthData() << std::endl;

  size_t iter_max = 2;
  nni_engine.RunInit(false);
  for (size_t iter = 0; iter < iter_max; iter++) {
    auto llhs = gp_engine.GetPerGPCSPLogLikelihoods();
    std::cout << "llhs: " << llhs << std::endl;
    // if (use_gp) {
    //   inst.MakeGPEngine();
    //   GPEngine* gp_engine = &inst.GetGPEngine();
    //   nni_engine.MakeGPEvalEngine(gp_engine);
    //   inst.EstimateBranchLengths(1e-5, 5);
    // }
    std::cout << "Iteration: " << iter << " of " << iter_max << std::endl;
    std::cout << "DAG: " << dag.NodeCount() << " " << dag.EdgeCountWithLeafSubsplits()
              << std::endl;
    std::cout << "Adjacent NNIs: " << nni_engine.GetAdjacentNNICount() << std::endl;
    nni_engine.RunMainLoop(false);
    std::cout << "Accepted NNIs: " << nni_engine.GetAcceptedNNICount() << std::endl;
    std::cout << "Scored NNIs: " << nni_engine.GetScoredNNIs() << std::endl;
    nni_engine.RunPostLoop(false);
    nni_engine.SyncAdjacentNNIsWithDAG();
  }
  std::cout << "FINAL: " << std::endl;
  std::cout << "DAG: " << dag.NodeCount() << " " << dag.EdgeCountWithLeafSubsplits()
            << std::endl;
}
